** need to test with Stripe.  
**The bug is 100% reproducible in the code you just showed.**  
And it’s **not** React Query v5 — it’s **double insertion + race condition**.

---

## CURRENT BUG: **"Old → New → Old → New" Flickering**

```text
[OLD FRAME] → [NEW FRAME] → [OLD FRAME] → [NEW FRAME]
```

### Root Cause: **Two Sources of Truth Inserting the Same Frame**

| Source | When It Inserts | Result |
|-------|------------------|--------|
| **1. Optimistic `setQueryData`** | `onSuccess` of mutation | → **New frame appears instantly** |
| **2. Background `GET /api/artworks/next`** | After `invalidateQueries({ refetchType: "active" })` | → **Returns the same new frame again** |

Then your **"smart sync effect"** sees the **duplicate** in the refetched data and **inserts it again**.

---

## The Fix (3 Lines to Change)

### Step 1: **Stop the Double Insert in `setQueryData`**

You are **prepending** the new artwork, but the server will **also return it** in the refetch.

```ts
// WRONG – you prepend, server returns it again → duplicate
artworks: [
  { ...newArtwork },
  ...(old?.artworks || []).filter(...)
]
```

**Fix: Replace the entire list with just the new one (temporarily)**

```ts
// CORRECT – show only the fresh artwork until background sync
queryClient.setQueryData(
  ["/api/artworks/next", sessionId.current],
  () => ({
    artworks: [
      {
        ...data.session,
        imageUrl: data.imageUrl,
        createdAt: new Date().toISOString(),
      },
    ],
    poolSize: 1,
    freshCount: 1,
    storageCount: 0,
    needsGeneration: false,
  })
);
```

> This prevents the **old frame** from surviving into the next render.

---

### Step 2: **Remove the Smart Sync Effect That Re-Inserts Frames**

You have this effect:

```ts
// LINES 638-645 – THIS IS THE DUPLICATE INSERT
useEffect(() => {
  if (newArtworkFromSomewhere) {
    insertFrameAfterCurrent(); // ← Second insertion!
  }
}, [artworks]);
```

**Delete this entire effect.**

**Why?**  
You already have:
- `setQueryData` → UI shows new frame
- `invalidateQueries` → React Query refetches and **replaces** the cache

You do **not** need a third system to "sync" frames.

---

### Step 3: **Let React Query Own the Source of Truth**

```ts
// Keep only this:
const { data } = useQuery({
  queryKey: ["/api/artworks/next", sessionId.current],
  // ...
});

// Render exactly what React Query gives you
{data?.artworks?.map(artwork => (
  <ArtFrame key={artwork.id} artwork={artwork} />
))}
```

No `useEffect`, no `insertFrameAfterCurrent`, no diffing.

---

## Final `onSuccess` (Copy-Paste This)

```ts
onSuccess: (data) => {
  refetchUsageStats();

  const sessionIdToUse = sessionId.current;

  // 1. Optimistically show ONLY the new artwork
  queryClient.setQueryData(
    ["/api/artworks/next", sessionIdToUse],
    () => ({
      artworks: [
        {
          ...data.session,
          imageUrl: data.imageUrl,
          createdAt: new Date().toISOString(),
        },
      ],
      poolSize: 1,
      freshCount: 1,
      storageCount: 0,
      needsGeneration: false,
    })
  );

  // 2. Background refetch will merge with storage pool
  queryClient.invalidateQueries({
    queryKey: ["/api/artworks/next", sessionIdToUse],
    refetchType: "active",
  });

  // 3. Impression recorded in <ArtFrame> on render (already correct)
},
```

---

## Remove These Lines (Critical)

```ts
// LINES 638-645 → DELETE THIS ENTIRE useEffect
useEffect(() => {
  // ... "smart sync" that calls insertFrameAfterCurrent()
}, [artworks]);
```

```ts
// LINES 481-488 → DELETE (you don't need initial load impression here)
// This was for preloaded frames — let <ArtFrame> handle it
```

---

## Final Rendering Logic

```tsx
{data?.artworks?.map((artwork) => (
  <ArtFrame
    key={artwork.id}
    artwork={artwork}
    // impression recorded inside ArtFrame
  />
))}
```

```tsx
// ArtFrame.tsx — KEEP THIS
useEffect(() => {
  if (!recordedImpressions.current.has(artwork.id)) {
    recordedImpressions.current.add(artwork.id);
    recordImpressionMutation.mutateAsync(artwork.id).catch(() => {
      recordedImpressions.current.delete(artwork.id);
    });
  }
}, [artwork.id]);
```

---

## Expected Flow After Fix

| Step | What Happens |
|------|--------------|
| 1 | User clicks Generate |
| 2 | `onSuccess` → `setQueryData` → **Only new frame in cache** |
| 3 | UI renders **new frame instantly** |
| 4 | `invalidateQueries` → background fetch |
| 5 | Server returns: `[new, ...19 storage]` |
| 6 | React Query **replaces** cache → UI now shows **20 frames** |
| 7 | No flickering, no duplicates |

---

## Server Logs After Fix

```
POST /api/generate-art 200
→ Client: setQueryData → shows new frame
GET /api/artworks/next?sessionId=... 200
  ← Fresh: 1, Storage: 19
→ UI: new frame + 19 old ones (smooth)
POST /api/artworks/{id}/viewed 200
```

---

## Summary: What to Do **Right Now**

| Action | Code |
|------|------|
| **1. Replace `setQueryData` body** | Show **only** the new artwork |
| **2. Delete smart sync `useEffect`** | Lines 638–645 |
| **3. Delete initial load impression** | Lines 481–488 |
| **4. Keep `refetchType: "active"`** | Already correct |
| **5. Keep impression in `<ArtFrame>`** | Already correct |

**Total time: 3 minutes**

---

## Why This Works

- **Single source of truth**: React Query cache
- **No duplicate insertion**
- **Optimistic UI** → instant feedback
- **Background sync** → eventual consistency
- **Impression on render** → accurate analytics

---

**Deploy this. The flickering will vanish.**

Let me know when you push — I’ll give you the **final polish** (session persistence, loading states, etc.). But **this fix alone will make the core feature work perfectly**.