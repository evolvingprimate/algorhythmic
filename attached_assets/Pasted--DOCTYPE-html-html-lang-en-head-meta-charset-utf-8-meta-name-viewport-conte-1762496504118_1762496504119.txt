<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebGL2 Latent-Space-ish Morph (A → B)</title>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin: 0; background:#0b0d12; color:#e8ebf0; display:grid; grid-template-columns: 320px 1fr; height:100vh; }
    aside { padding: 16px; border-right: 1px solid #1a1f2b; overflow:auto; }
    main { display:grid; place-items:center; }
    #gl { width: min(92vw, 1200px); height: min(92vh, 800px); background:#05060a; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    h1 { font-size: 16px; margin: 0 0 12px; color:#b7c5ff; letter-spacing: 0.2px; }
    h2 { font-size: 13px; margin: 18px 0 8px; color:#9bb0ff; font-weight:600; }
    .card { background:#0f1320; border:1px solid #1a2236; border-radius:12px; padding:12px; margin-bottom:12px; }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    input[type="range"] { width:100%; }
    .muted { color:#9aa3b2; font-size: 12px; }
    button, select, input[type="file"] {
      background:#11182a; color:#e8ebf0; border:1px solid #223150; padding:8px 10px; border-radius:10px;
    }
    button:hover { filter: brightness(1.1); }
    .small { font-size:12px; opacity:0.85 }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; color:#a6e3a1 }
  </style>
</head>
<body>
  <aside>
    <h1>Latent‑Space‑ish Morph</h1>
    <div class="card">
      <h2>Inputs</h2>
      <div class="grid2">
        <label class="small">Image A <input id="fileA" type="file" accept="image/*"></label>
        <label class="small">Image B <input id="fileB" type="file" accept="image/*"></label>
      </div>
      <p class="muted">Tip: square-ish images look best. If none loaded, demo generates gradients.</p>
    </div>
    <div class="card">
      <h2>Playback</h2>
      <div class="row">
        <button id="playBtn">▶︎ Play</button>
        <button id="pauseBtn">⏸︎ Pause</button>
        <button id="swapBtn">⇄ Swap</button>
      </div>
      <div style="margin-top:10px">
        <span class="small">Progress t</span>
        <input id="tSlider" type="range" min="0" max="1" step="0.001" value="0">
      </div>
      <div class="row" style="margin-top:8px">
        <label class="small">Speed <input id="speed" type="range" min="0" max="1" step="0.001" value="0.25"></label>
      </div>
    </div>
    <div class="card">
      <h2>Preset</h2>
      <div class="row">
        <select id="preset">
          <option value="dream">Dream Drift</option>
          <option value="glass">Glassine</option>
          <option value="aurora">Aurora</option>
          <option value="ink">Ink Bloom</option>
        </select>
      </div>
    </div>
    <div class="card">
      <h2>Parameters</h2>
      <label class="small">Displace Strength <input id="pDisp" type="range" min="0" max="1" step="0.001" value="0.35"></label>
      <label class="small">Detail Curl Noise <input id="pCurl" type="range" min="0" max="1" step="0.001" value="0.25"></label>
      <label class="small">Temporal Feedback <input id="pFb" type="range" min="0" max="0.3" step="0.001" value="0.08"></label>
      <label class="small">Edge Guidance <input id="pEdge" type="range" min="0" max="1" step="0.001" value="0.7"></label>
      <label class="small">Fine‑Band Weight <input id="pFine" type="range" min="0" max="1" step="0.001" value="0.6"></label>
      <label class="small">Color Mix (OKLab) <input id="pCol" type="range" min="0" max="1" step="0.001" value="1.0"></label>
    </div>
    <div class="card">
      <h2>About</h2>
      <div class="muted">GPU‑procedural morph without ML. Uses: multiband (mip‑Laplacian) blending, edge‑guided displacement (procedural curl + edge orientation), OKLab color interpolation, and light temporal feedback. <span class="mono">WebGL2</span> only.</div>
    </div>
  </aside>
  <main>
    <canvas id="gl"></canvas>
  </main>

<script>
// ---- Utility: WebGL2 setup ----
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2', { antialias: false, premultipliedAlpha: false });
if (!gl) alert('WebGL2 not supported.');
let W = 1024, H = 768;
function resize() {
  const r = canvas.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = Math.floor(r.width * dpr); H = Math.floor(r.height * dpr);
  canvas.width = W; canvas.height = H; gl.viewport(0,0,W,H);
}
window.addEventListener('resize', resize);
setTimeout(resize, 0);

function compile(type, src){
  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
function program(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}

const quadVS = `#version 300 es
precision mediump float;out vec2 vUv;void main(){
  vec2 p = vec2( (gl_VertexID<<1)&2, gl_VertexID&2 );
  vUv = p; gl_Position = vec4(p*2.0-1.0,0,1);
}`;

// ---- Shaders ----
// 1) Draw image into texture with optional generated gradient fallback
const blitFS = `#version 300 es
precision mediump float; in vec2 vUv; out vec4 o; uniform sampler2D uTex; uniform vec2 uRes; uniform int uHasTex; uniform vec3 uTint; 
float hash(vec2 p){ return fract(sin(dot(p, vec2(27.168, 91.583)))*43758.5453); }
void main(){
  if(uHasTex==1){ o = texture(uTex, vUv); }
  else{
    // nice fallback gradient with slight grain
    vec2 uv = vUv; vec3 a = vec3(0.12,0.18,0.35), b=vec3(0.83,0.65,0.35);
    float g = smoothstep(0.0, 1.0, uv.y);
    vec3 col = mix(a,b,g) * uTint;
    col += (hash(uv*uRes)*0.02);
    o = vec4(col,1.0);
  }
}`;

// 2) Main morph pass (procedural edge-guided displacement + multiband blend + OKLab color mix + feedback)
const mainFS = `#version 300 es
precision highp float; in vec2 vUv; out vec4 o;
uniform sampler2D uA; uniform sampler2D uB; uniform sampler2D uPrev;
uniform float uT; uniform vec2 uRes; 
// params
uniform float uDisp; uniform float uCurl; uniform float uFb; uniform float uEdge; uniform float uFine; uniform float uColMix; uniform int uPreset;

// --- helpers ---
vec3 rgb2lin(vec3 c){ return pow(c, vec3(2.2)); }
vec3 lin2rgb(vec3 c){ return pow(c, vec3(1.0/2.2)); }
// OKLab conversion (approx)
// Source: Bjorn Ottosson (oklab)
mat3 M1 = mat3(
  0.4122214708, 0.5363325363, 0.0514459929,
  0.2119034982, 0.6806995451, 0.1073969566,
  0.0883024619, 0.2817188376, 0.6299787005);
mat3 M2 = mat3(
  0.2104542553, 0.7936177850, -0.0040720468,
  1.9779984951, -2.4285922050, 0.4505937099,
  0.0259040371, 0.7827717662, -0.8086757660);
mat3 M1_INV = mat3(
  4.0767416621, -3.3077115913, 0.2309699292,
 -1.2684380046, 2.6097574011, -0.3413193965,
 -0.0041960863, -0.7034186147, 1.7076147010);
mat3 M2_INV = mat3(
  1.0000000000, 0.3963377774, 0.2158037573,
  1.0000000000, -0.1055613458, -0.0638541728,
  1.0000000000, -0.0894841775, -1.2914855480);

vec3 rgb_to_oklab(vec3 c){ vec3 lms = M1 * rgb2lin(c); lms = pow(lms, vec3(1.0/3.0)); return M2 * lms; }
vec3 oklab_to_rgb(vec3 c){ vec3 lms = M2_INV * c; lms = lms*lms*lms; return lin2rgb(M1_INV * lms); }

vec2 hash2(vec2 p){
  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
  return fract(sin(p)*43758.5453);
}
float noise(vec2 p){
  vec2 i=floor(p), f=fract(p);
  vec2 u=f*f*(3.0-2.0*f);
  float a=dot(hash2(i+vec2(0,0))-0.5,f-vec2(0,0));
  float b=dot(hash2(i+vec2(1,0))-0.5,f-vec2(1,0));
  float c=dot(hash2(i+vec2(0,1))-0.5,f-vec2(0,1));
  float d=dot(hash2(i+vec2(1,1))-0.5,f-vec2(1,1));
  return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}
vec2 curl(vec2 p){ // simple 2D curl of scalar noise field
  float e=1.0/256.0; float n1=noise(p+vec2(0.0,e)); float n2=noise(p-vec2(0.0,e));
  float n3=noise(p+vec2(e,0.0)); float n4=noise(p-vec2(e,0.0));
  float dx=(n1-n2)/(2.0*e); float dy=(n3-n4)/(2.0*e);
  return vec2(dy,-dx);
}

vec2 sobelDir(sampler2D t, vec2 uv){
  vec2 px = 1.0/uRes; // screen-space; images are sampled in vUv coords, so approximation
  vec3 tl = texture(t, uv + px*vec2(-1,-1)).rgb;
  vec3  l = texture(t, uv + px*vec2(-1, 0)).rgb;
  vec3 bl = texture(t, uv + px*vec2(-1, 1)).rgb;
  vec3 tr = texture(t, uv + px*vec2( 1,-1)).rgb;
  vec3  r = texture(t, uv + px*vec2( 1, 0)).rgb;
  vec3 br = texture(t, uv + px*vec2( 1, 1)).rgb;
  vec3  t0= texture(t, uv + px*vec2( 0,-1)).rgb;
  vec3  b0= texture(t, uv + px*vec2( 0, 1)).rgb;
  float gx = length(tr + 2.0*r + br - (tl + 2.0*l + bl));
  float gy = length(bl + 2.0*b0 + br - (tl + 2.0*t0 + tr));
  vec2 g = vec2(gx, gy);
  // orientation tangent along edges (rotate gradient by +90°)
  vec2 tangent = normalize(vec2(-g.y, g.x) + 1e-6);
  return tangent * clamp((gx+gy), 0.0, 1.0);
}

vec3 sampleLod(sampler2D t, vec2 uv, float lod){ return textureLod(t, uv, lod).rgb; }

void main(){
  // Easing per preset
  float t = uT;
  float tCoarse = smoothstep(0.05, 0.95, t);
  float tFine   = smoothstep(0.30, 0.80, t);
  float tColor  = smoothstep(0.15, 0.90, t);
  if(uPreset==1){ // Glassine
    tFine = smoothstep(0.15, 0.65, t);
    tColor = smoothstep(0.35, 0.95, t);
  } else if(uPreset==2){ // Aurora
    tCoarse = smoothstep(0.10, 0.85, t);
    tFine = smoothstep(0.35, 0.75, t);
  } else if(uPreset==3){ // Ink Bloom
    tFine = smoothstep(0.05, 0.55, t);
    tCoarse = smoothstep(0.30, 0.95, t);
  }

  // Edge-guided procedural displacement
  vec2 eA = sobelDir(uA, vUv);
  vec2 eB = sobelDir(uB, vUv);
  float edgeAmt = clamp(length(eA)+length(eB), 0.0, 1.0);
  vec2 flow = mix(eA, eB, t);
  // add curl noise detail
  vec2 cn = curl(vUv*vec2(3.0,3.0) + 17.0*vec2(t));
  flow = normalize(flow + uCurl*cn + 1e-4) * (uDisp * mix(0.8,1.5, edgeAmt*uEdge));

  // Warp A a bit toward B (tasteful, not melting)
  vec3 Aw = texture(uA, vUv - flow * t ).rgb;
  vec3 Bw = texture(uB, vUv + flow * (1.0-t) * 0.0 ).rgb; // keep B mostly unwarped for stability

  // Multi-band blend via mip LODs (coarse→fine). Use 3 bands for speed
  // Base (coarsest)
  vec3 baseA = sampleLod(uA, vUv - flow * t, 3.0);
  vec3 baseB = sampleLod(uB, vUv, 3.0);
  vec3 base  = mix(baseA, baseB, tCoarse);
  // Mid band
  vec3 midA  = sampleLod(uA, vUv - flow * t, 2.0) - sampleLod(uA, vUv - flow * t, 3.0);
  vec3 midB  = sampleLod(uB, vUv, 2.0) - sampleLod(uB, vUv, 3.0);
  vec3 mid   = mix(midA, midB, mix(tCoarse, tFine, 0.6));
  // Fine band
  vec3 finA  = sampleLod(uA, vUv - flow * t, 0.0) - sampleLod(uA, vUv - flow * t, 1.0);
  vec3 finB  = sampleLod(uB, vUv, 0.0) - sampleLod(uB, vUv, 1.0);
  vec3 fin   = mix(finA, finB, tFine);
  fin *= mix(0.25, 1.25, uFine);

  vec3 reconA = baseA + midA + finA;
  vec3 reconB = baseB + midB + finB;
  vec3 recon  = base + mid + fin; // structure blend result (RGB)

  // Perceptual color interpolation (OKLab) between warped A and B reconstructions
  vec3 okA = rgb_to_oklab(clamp(reconA, 0.0, 1.0));
  vec3 okB = rgb_to_oklab(clamp(reconB, 0.0, 1.0));
  vec3 okM = mix(okA, okB, tColor);
  vec3 colOK = oklab_to_rgb(okM);

  // Combine with structure blend vs direct OKLab mix
  vec3 combined = mix(recon, colOK, clamp(uColMix,0.0,1.0));

  // Temporal feedback (less near sharp edges)
  vec3 prev = texture(uPrev, vUv).rgb;
  float fbw = uFb * (1.0 - clamp(edgeAmt, 0.0, 1.0));
  vec3 outc = mix(combined, prev, fbw);

  o = vec4(clamp(outc, 0.0, 1.0), 1.0);
}`;

// ---- Pipeline setup ----
const progBlit = program(quadVS, blitFS);
const progMain = program(quadVS, mainFS);

// Fullscreen VAO
const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

// FBO helper
function makeTex(w, h){
  const t = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return t;
}
function makeFBO(tex){ const f = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER,f); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0); return f; }

let texA = makeTex(1024, 1024), texB = makeTex(1024, 1024);
let texPrev = makeTex(1024, 1024), texOut = makeTex(1024, 1024);
let fboA = makeFBO(texA), fboB = makeFBO(texB);
let fboPrev = makeFBO(texPrev), fboOut = makeFBO(texOut);

function blitTo(tex, imgOrNull, tint=[1,1,1]){
  gl.bindFramebuffer(gl.FRAMEBUFFER, (tex===texA)?fboA:(tex===texB?fboB:fboPrev));
  gl.useProgram(progBlit);
  gl.activeTexture(gl.TEXTURE0); if(imgOrNull){ gl.bindTexture(gl.TEXTURE_2D, imgOrNull); }
  gl.uniform1i(gl.getUniformLocation(progBlit,'uTex'), 0);
  gl.uniform2f(gl.getUniformLocation(progBlit,'uRes'), 1024, 1024);
  gl.uniform1i(gl.getUniformLocation(progBlit,'uHasTex'), imgOrNull?1:0);
  gl.uniform3f(gl.getUniformLocation(progBlit,'uTint'), tint[0], tint[1], tint[2]);
  gl.drawArrays(gl.TRIANGLES, 0, 3);
  gl.bindTexture(gl.TEXTURE_2D, tex); gl.generateMipmap(gl.TEXTURE_2D);
}

// Create backing textures from HTML images
function texFromImage(img){
  const t = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, gl.RGBA, gl.UNSIGNED_BYTE, img);
  gl.generateMipmap(gl.TEXTURE_2D);
  return t;
}

// Initial fallback content
let tintA = [1.05, 0.95, 1.0]; let tintB = [0.95, 1.0, 1.05];
blitTo(texA, null, tintA); blitTo(texB, null, tintB); blitTo(texPrev, null, [1,1,1]);

// UI handlers for file inputs
function loadFile(input, assignTex){
  const file = input.files && input.files[0]; if(!file) return;
  const img = new Image(); img.onload = ()=>{
    const t = texFromImage(img);
    // draw into our main fixed-size atlas with blit shader to get mipmaps
    gl.bindTexture(gl.TEXTURE_2D, t);
    if(assignTex==='A') { texA = t; fboA = makeFBO(texA); }
    else { texB = t; fboB = makeFBO(texB); }
  };
  img.src = URL.createObjectURL(file);
}

fileA.onchange = ()=>loadFile(fileA, 'A');
fileB.onchange = ()=>loadFile(fileB, 'B');

// Playback & params
let playing = false; let t = 0; let dir = 1;
playBtn.onclick = ()=> playing = true; pauseBtn.onclick = ()=> playing = false;
swapBtn.onclick = ()=> { const tmp = texA; texA=texB; texB=tmp; };

function presetIndex(){
  const v = preset.value; return v==='dream'?0: v==='glass'?1: v==='aurora'?2:3;
}

// ---- Render loop ----
function render(ts){
  requestAnimationFrame(render);
  resize();
  if(playing){ t += (Number(speed.value)*0.5 + 0.01) * dir * (1/60); if(t>1){ t=1; dir=-1; } if(t<0){ t=0; dir=1; } tSlider.value = t.toFixed(3); }
  else { t = Number(tSlider.value); }

  gl.bindFramebuffer(gl.FRAMEBUFFER, fboOut);
  gl.useProgram(progMain);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.uniform1i(gl.getUniformLocation(progMain,'uA'), 0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texB);
  gl.uniform1i(gl.getUniformLocation(progMain,'uB'), 1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, texPrev);
  gl.uniform1i(gl.getUniformLocation(progMain,'uPrev'), 2);

  gl.uniform1f(gl.getUniformLocation(progMain,'uT'), t);
  gl.uniform2f(gl.getUniformLocation(progMain,'uRes'), W, H);
  gl.uniform1f(gl.getUniformLocation(progMain,'uDisp'), Number(pDisp.value));
  gl.uniform1f(gl.getUniformLocation(progMain,'uCurl'), Number(pCurl.value));
  gl.uniform1f(gl.getUniformLocation(progMain,'uFb'), Number(pFb.value));
  gl.uniform1f(gl.getUniformLocation(progMain,'uEdge'), Number(pEdge.value));
  gl.uniform1f(gl.getUniformLocation(progMain,'uFine'), Number(pFine.value));
  gl.uniform1f(gl.getUniformLocation(progMain,'uColMix'), Number(pCol.value));
  gl.uniform1i(gl.getUniformLocation(progMain,'uPreset'), presetIndex());

  gl.drawArrays(gl.TRIANGLES, 0, 3);

  // present to screen & update prev
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  // blit fboOut to canvas
  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fboOut);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
  gl.blitFramebuffer(0,0,1024,1024, 0,0,W,H, gl.COLOR_BUFFER_BIT, gl.LINEAR);

  // swap prev = out
  const tmpTex = texPrev, tmpFbo = fboPrev; texPrev = texOut; fboPrev = fboOut; texOut = tmpTex; fboOut = tmpFbo;
}
requestAnimationFrame(render);
</script>
</body>
</html>
